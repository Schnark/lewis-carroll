This is a tiny search engine. It is much inspired by [MiniSearch](https://github.com/lucaong/minisearch) and mainly intended for my Lewis Carroll collection, but if your needs match mine, you can use it, too.

There are two parts: The code to create the index, and the code to run the search.

To create the index you need `prefix-tree.js` and `search-index-builder.js`. You might want to adapt `SearchIndexBuilder.split`, `SearchIndexBuilder.normalizeWord`, and `SearchIndexBuilder.isStopword`. Then call `searchIndexBuilder = new SearchIndexBuilder(storeFields, searchFields);` where the two parameters are arrays of strings indicating the keys with the data to store and to search. You should order the `searchFields` to have longer fields first. Then for each document call `searchIndexBuilder.addDocument(doc);` where `doc` is an object with the expected keys. Once you are done, store the result of `JSON.stringify(searchIndexBuilder)`.

For the search you need `prefix-tree.js` and `doc-finder.js`. As before, you might want to adapt `DocFinder.normalizeWord` and `DocFinder.isStopword` to match the ones used for indexing. Then get and parse the stored index and call `docFinder = DocFinder.fromJSON(parsedJSON);`. This function has two optional parameters, the first is an array of numbers to boost the score for specific fields, the second an object with the parameters to calculate the score. There are two methods you can call: `docFinder.suggest(query)` gives you an array of suggestions for a (partial) query. The main method is `docFinder.search(query, options)`, where options is an optional object with the following entries: `combine` for how to combine terms by default (defaults to `'AND'`, may be set to `'OR'`), `prefix` and `fuzzy` boolean (defaulting to `false`) to enable prefix/fuzzy search by default, `fieldIndex` the numeric 1-based index of the field to search and `fields` an object to map search names to (1-based) index numbers of the respective search field. This will parse and execute the query and return an array of results, each entry an object with `data` containing the stored data (as array), `score` the raw score for the match, and `terms` an array with all matched terms.

There are helper files to analyze and compare indices, to build an index from a sitemap, and the actual script for the search.